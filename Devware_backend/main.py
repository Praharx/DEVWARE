import asyncio
from typing import Union
from fastapi import FastAPI
from prisma import Prisma
from prisma.models import User
from langchain_community.chat_models import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
)

knowledge_base = ''
ghdata = ''
onboard = ''

async def main() -> None:
    print('Start of the function')
    db = Prisma()
    await db.connect()

    knowledge_base = await db.knowledgebase.find_first(
        where={
        'OR': [
            {'email': {'contains': 'harshana555prajapati@gmail.com'}}
        ]
    }
    )

    ghdata = await db.ghdata.find_first(
        where={
        'OR': [
            {'email': {'contains': 'harshana555prajapati@gmail.com'}}
        ]
    }
    )
    
    onboard = await db.useronboard.find_first(
        where={
        'OR': [
            {'email': {'contains': 'harshana555prajapati@gmail.com'}}
        ]
     }
    )
    
    await db.disconnect()

def initials(context, thoughts, tone):
    chat = ChatOpenAI(
        temperature=0.9,
        openai_api_key='',
        model='gpt-4'
    )

    template_string = '''
        You're to create a Twitter post for the user. The post should meet the following requirements: 
        -Structure and Clarity: Keep the post structured and clean, ensuring that the content flows logically and is easy to read.
        -Human Touch: Craft the post in a way that it does not appear to be generated by an AI. Aim for a natural, conversational tone and avoid robotic or overly formal language.
        -User Context and Skills: Ensure that the post aligns with the user's technical background, interests, and skills, as provided in {onboard} (e.g., a brief description of the user's profile or areas of expertise).
        -Character Limit: The post should strictly be limited to 280 characters, adhering to Twitter's character limit.
        -Personalization and Emojis: Personalize the post to the user's profile, and consider adding up to two emojis if they enhance the content and align with the tone. However, do not add emojis unnecessarily or excessively.
        -User Knowledge Base: Incorporate relevant information from the user's {knowledge_base} (e.g., a collection of the user's liked posts or technical experiences) to ensure the post resonates with their interests.
        -Programming Languages: Tailor the post to reflect the programming languages the user has experience with, as mentioned in {ghdata} (e.g., a list of programming languages the user has coded in).
        -Tone and Voice: Aim for a [casual/professional/humorous] tone and voice in the post, suitable for the user's profile and the intended audience.
    '''

    prompt_template = ChatPromptTemplate.from_template(template_string)
    message = prompt_template.format_messages(onboard= onboard, knowledge_base= knowledge_base, ghdata= ghdata)
    reply = chat(message)
    print(reply)
    return {"post": reply, "success": True}

@app.get("/")
def read_root(context: str, tone: str, thoughts):
    asyncio.run(main())
    print(f'context: {context}, tone: {tone}, thoughts: {thoughts}')
    return initials(context, thoughts , tone)
    


    

